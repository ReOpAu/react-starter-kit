---
description: 
globs: 
alwaysApply: true
---
# âœ… RULE: Enforce Unified Action-Handler Framework

This rule prevents logic divergence between UI event handlers and Agent client tools by enforcing the use of a single, centralized Action Handler.

## The Core Principle

**NEVER** implement business logic directly inside a UI event handler (e.g., `handleSelectResult`) or an Agent client tool (e.g., `selectSuggestion`). These functions are **Action Triggers** only. Their sole responsibility is to gather necessary parameters and delegate to the centralized **Action Handler** hook.

---

## ðŸš« Anti-Pattern: Logic in UI Event Handlers

UI event handlers in `address-finder.tsx` should be trivial. They find the right data and call the handler.

### âŒ FORBIDDEN in `address-finder.tsx`:

```typescript
// âŒ FORBIDDEN: Any business logic inside the event handler.
const handleSelectResult = useCallback(async (result: Suggestion) => {
    // âŒ NO classification logic
    const intent = classifySelectedResult(result);

    // âŒ NO conditional logic
    if (intent === 'address') {
        // âŒ NO API calls
        const validation = await validateAddressAction(...);

        // âŒ NO state updates
        setSelectedResult(validation.enrichedAddress);
    } else {
        setSelectedResult(result);
    }
}, [/* ... */]);
```

### âœ… REQUIRED Pattern: Delegate to Handler

```typescript
// âœ… REQUIRED: The handler should be a one-line delegation.
import { useActionHandler } from '~/hooks/useActionHandler'; // Hypothetical path

// ...

const { handleSelect } = useActionHandler();

const handleSelectResult = useCallback((result: Suggestion) => {
    // âœ… CORRECT: Just call the central handler.
    handleSelect(result);
}, [handleSelect]);
```

---

## ðŸš« Anti-Pattern: Logic in Agent Client Tools

Client tools in `useAddressFinderClientTools.ts` must also be trivial wrappers that delegate to the central handler.

### âŒ FORBIDDEN in `useAddressFinderClientTools.ts`:

```typescript
// âŒ FORBIDDEN: Any business logic inside the tool definition.
const clientTools = useMemo(() => ({
    selectSuggestion: async (params: { placeId: string }) => {
        // âŒ NO data fetching
        const suggestion = findSuggestionInCache(params.placeId);
        
        // âŒ NO classification logic
        const intent = classifySelectedResult(suggestion);

        // âŒ NO conditional logic or API calls
        if (intent === 'address') {
            const validation = await validateAddressAction(...);
            // ...
        }

        // âŒ NO direct state updates
        // setSelectedResult(...)

        return JSON.stringify({ status: 'error', message: 'Logic must be in useActionHandler.' });
    }
}), [/* ... */]);
```

### âœ… REQUIRED Pattern: Delegate to Handler

```typescript
// âœ… REQUIRED: The tool should be a one-line delegation.
import { useActionHandler } from '~/hooks/useActionHandler'; // Hypothetical path

// ...

const { handleSelect } = useActionHandler();

const clientTools = useMemo(() => ({
    selectSuggestion: async (params: { placeId: string; description: string; }) => {
        // âœ… CORRECT: Rehydrate the object and delegate to the handler.
        const suggestion: Suggestion = { ...params, types: [] };
        await handleSelect(suggestion);
        
        return JSON.stringify({ status: 'success', message: 'Selection processed by central handler.' });
    }
}), [handleSelect]);
```

By enforcing this separation, we make it structurally impossible for UI and Agent logic to diverge, permanently eliminating this class of bugs.
