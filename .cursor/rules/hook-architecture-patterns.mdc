---
description: 
globs: **/hooks/**/*.ts,**/utils/*.ts,**/routes/**/*.tsx,app/components/**/*.tsx
alwaysApply: false
---
# Hook Architecture & Coding Practices

## ğŸ—ï¸ HOOK STRUCTURE PATTERNS

### âœ… REQUIRED Hook Patterns

#### 1. Stable Logging Utility Pattern
```typescript
// âœ… ALWAYS include this pattern in custom hooks
const log = useCallback((...args: any[]) => {
  if (useAddressFinderStore.getState().isLoggingEnabled) {
    console.log('[HookName]', ...args);
  }
}, []); // âœ… Empty dependency array makes this completely stable
```

#### 2. Clean Hook Interface Pattern
```typescript
// âœ… REQUIRED: Export clear, focused hook interface
export function useMyHook(param1: Type1, param2: Type2) {
  // Internal logic
  
  return {
    // âœ… Return only what's needed
    primaryFunction,
    secondaryFunction,
    status: { isLoading, error }
  };
}
```

#### 3. Dependencies Parameter Pattern
```typescript
// âœ… CORRECT: Pass dependencies as parameters, not import global state
export function useClientTools(
  getSessionToken: () => string,
  clearSessionToken: () => void
) {
  // Hook logic uses passed functions
}

// âŒ NEVER DO: Import global state directly in hooks
// import { useAddressFinderStore } from '~/stores/store';
```

### âœ… STABLE REFERENCE PATTERNS

#### 1. useCallback Dependencies
```typescript
// âœ… CORRECT: Minimal, stable dependencies
const stableFunction = useCallback((param: string) => {
  // Use getState() pattern to avoid reactive dependencies
  const { setting } = useStore.getState();
  doSomething(param, setting);
}, []); // âœ… Empty deps - completely stable

// âŒ FORBIDDEN: Reactive dependencies that cause re-renders
const unstableFunction = useCallback((param: string) => {
  doSomething(param, reactiveSetting);
}, [reactiveSetting]); // âŒ Causes unnecessary re-renders
```

#### 2. Infinite Loop Prevention
```typescript
// âœ… REQUIRED: Never include setters in useEffect dependencies
useEffect(() => {
  setState(newValue);
  syncToAgent();
}, [newValue]); // âœ… Only reactive values, no setters

// âŒ FORBIDDEN: Including setters causes infinite loops
useEffect(() => {
  setState(newValue);
  syncToAgent();
}, [newValue, setState, syncToAgent]); // âŒ setState/syncToAgent cause loops
```

## ğŸ¯ FILE ORGANIZATION PATTERNS

### âœ… REQUIRED File Structure

#### 1. Pure Utility Functions
```typescript
// ğŸ“ app/utils/[feature]Utils.ts
// âœ… ONLY pure functions, no hooks, no side effects
export const classifyResult = (data: Type): ResultType => {
  // Pure logic only
  return result;
};

export const deduplicateItems = <T extends Item>(items: T[]): T[] => {
  // Pure deduplication logic
  return deduplicated;
};
```

#### 2. Focused Custom Hooks
```typescript
// ğŸ“ app/hooks/use[Feature][Concern].ts
// âœ… Single responsibility hooks
export function useAudioManager() {
  // âœ… ONLY audio-related logic
}

export function useClientTools(deps) {
  // âœ… ONLY client tools logic
}

// âŒ NEVER: Multi-concern hooks
export function useEverything() {
  // âŒ Audio + API + State + UI logic mixed
}
```

#### 3. Hook Dependency Chain
```typescript
// âœ… CORRECT: Clear dependency flow
export default function Component() {
  // Level 1: Utility functions
  const getToken = useCallback(() => generateToken(), []);
  
  // Level 2: Focused hooks with dependencies
  const clientTools = useClientTools(getToken, clearToken);
  const { conversation } = useConversationManager(clientTools);
  
  // Level 3: Orchestration hooks
  const { startRecording } = useAudioManager();
  
  // âœ… Clean, readable dependency chain
}
```

## ğŸš« FORBIDDEN PATTERNS

### âŒ Anti-Patterns to Avoid

#### 1. Complex Hook Interfaces
```typescript
// âŒ FORBIDDEN: Too many parameters (>5 indicates poor separation)
export function useComplexHook(
  param1: string,
  param2: boolean,
  param3: () => void,
  param4: any[],
  param5: object,
  param6: string  // âŒ TOO MANY - redesign needed
) {
  // This violates single responsibility
}
```

#### 2. State Setter Dependencies
```typescript
// âŒ FORBIDDEN: State setters in dependencies
const { setState, setOtherState } = useStore();

useEffect(() => {
  setState(value);
}, [value, setState]); // âŒ setState is stable, don't include

useCallback(() => {
  doSomething();
}, [setOtherState]); // âŒ Setters are stable by design
```

#### 3. Circular Dependencies
```typescript
// âŒ FORBIDDEN: Hooks importing each other
// useAudioManager.ts
import { useClientTools } from './useClientTools'; // âŒ Circular

// useClientTools.ts  
import { useAudioManager } from './useAudioManager'; // âŒ Circular

// âœ… CORRECT: Pass dependencies as parameters
export function useAudioManager(clientTools: ClientTools) {
  // No direct import, use passed dependency
}
```

## ğŸ§  COMPONENT PATTERNS

### âœ… Brain Component Rules

#### 1. Hook Orchestration
```typescript
// âœ… CORRECT: Brain orchestrates with minimal interfaces
export default function BrainComponent() {
  // âœ… Initialize hooks with clear dependencies
  const clientTools = useClientTools(getToken, clearToken);
  const { conversation } = useConversationManager(clientTools);
  const { startRecording } = useAudioManager();
  
  // âœ… Simple event handlers
  const handleSelection = useCallback((data: SelectionType) => {
    updateGlobalState(data);
    syncToAgent();
  }, [updateGlobalState, syncToAgent]);
  
  return (
    <SelfContainedWidget onSelect={handleSelection} />
  );
}
```

#### 2. Widget Integration
```typescript
// âœ… CORRECT: Minimal widget interfaces (max 3 callbacks)
<Widget 
  onSelect={handleSelect}
  onError={handleError}
  onComplete={handleComplete}
/>

// âŒ FORBIDDEN: Complex widget interfaces
<Widget
  data={data}              // âŒ Parent managing widget data
  isLoading={isLoading}    // âŒ Parent managing widget state
  onSearch={handleSearch}  // âŒ Parent managing widget queries
  sessionToken={token}     // âŒ Parent managing widget sessions
  error={error}           // âŒ Parent managing widget errors
/>
```

## ğŸ”§ PERFORMANCE PATTERNS

### âœ… REQUIRED Optimization Patterns

#### 1. Stable References
```typescript
// âœ… CORRECT: Minimize dependencies for stability
const stableHandler = useCallback((data: Data) => {
  // Use getState() for non-reactive values
  const { config } = useStore.getState();
  processData(data, config);
}, []); // âœ… Empty deps = maximum stability

const memoizedValue = useMemo(() => {
  return expensiveComputation(props.data);
}, [props.data]); // âœ… Only include values that should trigger recomputation
```

#### 2. Cleanup Patterns
```typescript
// âœ… REQUIRED: Proper cleanup in hooks
export function useAudioManager() {
  const mediaStreamRef = useRef<MediaStream | null>(null);
  
  const cleanup = useCallback(() => {
    if (mediaStreamRef.current) {
      mediaStreamRef.current.getTracks().forEach(track => track.stop());
      mediaStreamRef.current = null;
    }
  }, []);
  
  useEffect(() => {
    return cleanup; // âœ… Cleanup on unmount
  }, [cleanup]);
  
  return { cleanup };
}
```

## ğŸ“ ERROR HANDLING PATTERNS

### âœ… REQUIRED Error Patterns

#### 1. Graceful Degradation
```typescript
// âœ… CORRECT: Graceful error handling
export function useApiHook() {
  const [error, setError] = useState<Error | null>(null);
  
  const apiCall = useCallback(async (params: Params) => {
    try {
      const result = await api.call(params);
      setError(null); // âœ… Clear previous errors
      return result;
    } catch (err) {
      setError(err instanceof Error ? err : new Error(String(err)));
      log('âŒ API call failed:', err);
      return null; // âœ… Graceful fallback
    }
  }, []);
  
  return { apiCall, error };
}
```

#### 2. Error Boundaries
```typescript
// âœ… REQUIRED: Validate parameters in tools/hooks
export function useClientTools() {
  const searchAddress = useCallback(async (params: unknown) => {
    // âœ… Always validate inputs
    if (typeof params !== 'object' || !params || !('query' in params)) {
      const errorMessage = "Invalid parameters for searchAddress";
      log('âŒ Tool validation failed:', { params });
      return JSON.stringify({ status: "error", error: errorMessage });
    }
    
    // Continue with validated params
  }, []);
}
```

## ğŸ¯ TESTING CONSIDERATIONS

### âœ… Design for Testability

#### 1. Pure Functions First
```typescript
// âœ… TESTABLE: Pure utilities are easily testable
// app/utils/helpers.ts
export const classifyResult = (data: Data): ResultType => {
  // Pure function - easy to unit test
  return classification;
};
```

#### 2. Injectable Dependencies
```typescript
// âœ… TESTABLE: Dependencies can be mocked
export function useClientTools(
  getToken: () => string,    // âœ… Can be mocked
  clearToken: () => void     // âœ… Can be mocked
) {
  // Hook logic using injected dependencies
}
```

## ğŸš€ MIGRATION CHECKLIST

When creating new hooks or refactoring existing code:

- [ ] âœ… Is the hook focused on a single concern?
- [ ] âœ… Are dependencies passed as parameters, not imported?
- [ ] âœ… Does it use the stable logging pattern?
- [ ] âœ… Are useCallback dependencies minimal and stable?
- [ ] âœ… Does it avoid including setters in useEffect dependencies?
- [ ] âœ… Does it properly clean up resources?
- [ ] âœ… Are error cases handled gracefully?
- [ ] âœ… Is the interface minimal (â‰¤5 parameters/returns)?
- [ ] âœ… Can it be tested in isolation?
- [ ] âœ… Does it follow the established naming patterns?

Follow these patterns to maintain consistency with the established architecture and prevent common issues like infinite loops, performance problems, and tight coupling.
