---
description: 
globs: 
alwaysApply: true
---
---
description: State manipulation strategy for React Query + Zustand + ElevenLabs agent sync. Enforces shared state manipulation as the synchronization mechanism between UI interactions and conversational AI agent.
globs: ["**/routes/**/*.tsx", "**/stores/**/*.ts", "**/hooks/**/*.ts", "**/components/**/address-finder/**/*.tsx", "**/components/**/conversation/**/*.tsx"]
alwaysApply: false
---

## META-ARCHITECTURAL PRINCIPLE: Purpose-Driven Component Design

### UNIVERSAL TRUTH: Only Critical Information Flows to The Brain
**Information Flow Hierarchy:**
```
INTERNAL WIDGET STATE ‚Üí (Filter) ‚Üí CRITICAL EVENTS ‚Üí The Brain ‚Üí AI Agent
```

### CRITICAL vs INTERNAL Information Classification

#### ‚úÖ CRITICAL (Must Sync to Agent):
- **User selections**: Address chosen, file uploaded, option picked
- **Intent changes**: User switches goals or modes  
- **State transitions**: Form completion, process steps, mode switching
- **Error states**: API failures, validation errors, system issues
- **Completion events**: Tasks finished, submissions successful

#### ‚ùå INTERNAL (Widget-Only, Never Sync):
- **Cosmetic states**: Focus/blur, hover, visual feedback
- **Animation states**: Transitions, loading spinners, progress bars
- **Validation formatting**: Real-time input formatting, character counters
- **UI convenience**: Dropdown show/hide, tab highlighting, tooltip display
- **Processing states**: Internal calculations, data transformation

### PURPOSE-FIRST DEVELOPMENT RULES

#### Before Building ANY Component:
1. **What is this component's TRUE purpose?** (Data collection? User feedback? Display?)
2. **What CRITICAL information does it produce?** (Only final outcomes matter to user's goal)
3. **What should NEVER leave this component?** (All internal UX state and cosmetic changes)
4. **How does it serve the user's actual intent?** (Focus on end goal, not interaction mechanics)

#### Component Classification:
- **üß† Brain Components** (Few): Orchestrate global state, call `syncToAgent()`, handle agent communication
- **üîß Widget Components** (Many): Self-contained UX, report only critical outcomes via callbacks
- **üé® Display Components** (Passive): Pure presentation, no state or side effects

#### Development Efficiency Rules:
- ‚úÖ **Widgets can have complex internal state** for excellent UX
- ‚úÖ **Widgets communicate ONLY via callbacks** to their Brain (`onSelect`, `onError`, `onComplete`)
- ‚ùå **Widgets NEVER import global stores** or call `syncToAgent()`
- ‚ùå **Widgets NEVER know about** recording mode, agent status, or global application flow

## HYBRID VOICE + MANUAL MODE RULES

### CRITICAL: requestManualInput() Tool Behavior
When the agent calls `requestManualInput()`, it should **NEVER stop the conversation**. Instead:

#### ‚úÖ CORRECT Hybrid Mode Implementation:
```typescript
requestManualInput: async (params) => {
  // KEEP conversation active - NO stopRecording() or endSession()
  // ONLY set UI flags to enable widget during conversation
  setAgentRequestedManual(true);
  
  // Add helpful context for user
  addHistory({ type: 'agent', text: `ü§ñ ‚Üí üìù ${reason}` });
  
  return JSON.stringify({
    status: "hybrid_mode_activated",
    message: "Manual input enabled - conversation continues"
  });
}
```

#### ‚ùå FORBIDDEN: Do NOT Stop Conversation
```typescript
// ‚ùå NEVER DO THIS - breaks hybrid mode concept
requestManualInput: async (params) => {
  await conversation.endSession(); // ‚ùå Conversation should continue
  setIsRecording(false);           // ‚ùå Recording should stay active
  // This makes it "switch modes" instead of "collaborative input"
}
```

### UI Rendering During Hybrid Mode
The Brain component should render ManualSearchForm when EITHER:
- `!isRecording` (traditional manual mode), OR  
- `isRecording && agentRequestedManual` (hybrid mode)

```typescript
// ‚úÖ CORRECT conditional rendering for hybrid support
const shouldShowManualForm = !isRecording || agentRequestedManual;

{shouldShowManualForm ? (
  <ManualSearchForm onSelect={handleSelectResult} />
) : (
  <div>Voice conversation is active</div>
)}
```

### Hybrid Mode State Flow
```
Agent calls requestManualInput()
‚îú‚îÄ isRecording stays TRUE (conversation continues)
‚îú‚îÄ agentRequestedManual becomes TRUE (enables widget)
‚îú‚îÄ UI shows ManualSearchForm WITH voice controls
‚îú‚îÄ User types ‚Üí Widget callbacks ‚Üí Brain ‚Üí Agent sync
‚îî‚îÄ Agent continues conversation with new data
```

### Widget Isolation Maintained
Even in hybrid mode, ManualSearchForm:
- ‚úÖ Remains unaware of `isRecording` state
- ‚úÖ Uses same `onSelect()` callback interface
- ‚úÖ Handles own autocomplete API calls
- ‚úÖ Never imports global stores

The Brain orchestrates the hybrid mode WITHOUT breaking Widget isolation.

## CORE PRINCIPLE: State Manipulation as Synchronization Mechanism
- SHARED STATE: Both UI and Agent manipulate the SAME state stores (React Query + Zustand)
- SYNCHRONIZATION: State manipulation IS the synchronization strategy
- React Query is the ONLY source of truth for ALL API data (Google Places, Address Validation)
- Zustand stores UI-specific state and syncs FROM React Query for agent communication
- Persistent refs handle conversation state survival across ElevenLabs resets
- NEVER create dual storage patterns
- ALWAYS maintain mode isolation between voice and manual input

## üèõÔ∏è The Four Pillars of Brain State

To manage complexity, the "Brain" (our central state) is organized into four distinct categories. Understanding this separation is key to developing features reliably.

| Category | Purpose | Where It Lives | Primary Changers |
| :--- | :--- | :--- | :--- |
| **1. API State** | **The "What"**: Represents knowledge from the outside world (search results, validation status). It is asynchronous and volatile. | **React Query** | System, Agent |
| **2. User Input & Intent** | **The "Why"**: Captures the user's direct inputs (text, clicks) and our inferred goal for them. | **Zustand** | User, Agent |
| **3. App Mode & UI** | **The "How"**: Defines the application's current interaction mode (e.g., voice vs. manual) and controls UI visibility. | **Zustand** | User, Agent, System |
| **4. Session & History** | **The "Where We've Been"**: Maintains a contextual log of interactions and session-specific data (like billing tokens). | **Zustand, Refs** | User, Agent, System |

## ‚öôÔ∏è How State Changes: Primary Actions & Cascading Reactions

Our architecture's reliability comes from a clear separation between the *cause* of a state change and its *effect*.

### 1. Primary Changes (Direct Actions)
These are the **"cause"** of a state update. They are explicit, imperative state setter calls that happen directly inside an event handler or an agent tool in response to a specific action.

-   **Examples**:
    -   A user types in a field, triggering `setSearchQuery("new text")`.
    -   A user clicks a suggestion, triggering `setSelectedResult(...)`.
    -   The agent uses a tool, triggering `setAgentRequestedManual(true)`.

### 2. Secondary Changes (Cascading Reactions)
These are the **"effect"** of one or more primary changes. They happen automatically and reactively, ensuring the rest of the application ecosystem stays consistent with the new state.

-   **Implementation**: This is handled almost exclusively by our **centralized `useEffect` hook** in `address-finder.tsx`.
-   **The Flow**:
    1.  A **Primary Change** updates a state variable (e.g., `selectedResult`).
    2.  React detects this change.
    3.  The main `useEffect`, which "listens" to `selectedResult`, is triggered.
    4.  The **Secondary Changes** inside the effect now run automatically: the Zustand bridge is updated, and `syncToAgent()` is called, synchronizing the new state to the agent.

**Why is this critical?** This pattern makes our code predictable, testable, and robust. Event handlers are simple and only responsible for their direct action, while the complex logic of synchronization is centralized, de-duplicated, and guaranteed to run when‚Äîand only when‚Äîit's needed.

## ‚ö†Ô∏è CRITICAL: INFINITE LOOP PREVENTION RULES

### üö´ FORBIDDEN DEPENDENCY PATTERNS (Will Cause Infinite Loops)

#### 1. Never Include State Setters in useEffect Dependencies
```typescript
// ‚ùå NEVER DO THIS - setState functions cause infinite loops
useEffect(() => {
  setApiResults({ suggestions, isLoading });
}, [suggestions, isLoading, setApiResults]); // ‚ùå setApiResults causes loop

// ‚úÖ ALWAYS DO THIS - exclude stable setter functions
useEffect(() => {
  setApiResults({ suggestions, isLoading });
}, [suggestions, isLoading]); // ‚úÖ Only reactive dependencies
```

#### 2. Never Include Zustand Actions in Dependencies
```typescript
// ‚ùå NEVER DO THIS - Zustand setters cause infinite loops
const { setSearchQuery, setSelectedResult } = useAddressFinderStore();

useEffect(() => {
  setSearchQuery(newQuery);
}, [newQuery, setSearchQuery]); // ‚ùå setSearchQuery causes loop

// ‚úÖ ALWAYS DO THIS - Zustand setters are stable by design
useEffect(() => {
  setSearchQuery(newQuery);
}, [newQuery]); // ‚úÖ Only include reactive values
```

#### 3. Never Include Callback Functions with Unstable Dependencies
```typescript
// ‚ùå NEVER DO THIS - unstable callback in dependencies
const log = useCallback((...args) => {
  if (isLoggingEnabled) console.log(...args);
}, [isLoggingEnabled]); // ‚ùå Reactive dependency makes callback unstable

useEffect(() => {
  performAction();
  log('Action performed');
}, [performAction, log]); // ‚ùå log changes when isLoggingEnabled changes

// ‚úÖ ALWAYS DO THIS - make callbacks completely stable
const log = useCallback((...args) => {
  const { isLoggingEnabled } = useAddressFinderStore.getState();
  if (isLoggingEnabled) console.log(...args);
}, []); // ‚úÖ Empty deps - uses getState() pattern

useEffect(() => {
  performAction();
  log('Action performed');
}, [performAction]); // ‚úÖ log is now stable, removed from deps
```

#### 4. Never Create State Update Cycles in useEffect
```typescript
// ‚ùå NEVER DO THIS - state updates trigger more state updates
useEffect(() => {
  if (isAddressSelected) {
    setShowSuggestions(false);
    return;
  }
  
  if (suggestions.length > 0 && hasMinimumChars) {
    setShowSuggestions(true); // ‚ùå State update in effect with state dependencies
  }
}, [suggestions, isAddressSelected, hasMinimumChars]); // ‚ùå Causes cascading updates

// ‚úÖ ALWAYS DO THIS - handle state updates in event handlers
const handleInputChange = useCallback((value) => {
  setInputValue(value);
  
  // Handle suggestion visibility imperatively
  if (isAddressSelected) {
    setShowSuggestions(false);
  } else if (value.length >= MIN_CHARS) {
    setShowSuggestions(true);
  } else {
    setShowSuggestions(false);
  }
}, [isAddressSelected]); // ‚úÖ Minimal dependencies, no state update cycles
```

### ‚úÖ REQUIRED PATTERNS TO PREVENT INFINITE LOOPS

#### 1. Stable Callback Pattern for Logging and Utilities
```typescript
// ‚úÖ ALWAYS DO THIS - completely stable callbacks
const log = useCallback((...args: any[]) => {
  // Use getState() pattern to avoid reactive dependencies
  const { isLoggingEnabled } = useAddressFinderStore.getState();
  if (isLoggingEnabled) {
    console.log('[AddressFinder]', ...args);
  }
}, []); // ‚úÖ Empty dependency array makes this completely stable
```

#### 2. Safe State Synchronization Pattern
```typescript
// ‚úÖ ALWAYS DO THIS - avoid sync loops
const { syncToAgent } = useAgentSync(); // ‚úÖ This is stable

useEffect(() => {
  // Direct sync without additional state updates
  syncToAgent();
}, [suggestions, isLoading, error, isRecording]); // ‚úÖ Only include reactive values

// ‚ùå NEVER include syncToAgent in dependencies - it's stable by design
```

#### 3. Event-Driven State Updates Instead of Reactive Effects
```typescript
// ‚úÖ ALWAYS DO THIS - handle complex state logic in event handlers
const handleSearch = useCallback((query: string) => {
  setSearchQuery(query);
  
  // Handle all related state updates imperatively
  setShowSuggestions(query.length >= MIN_CHARS);
  setSelectedIndex(-1);
  setIsAddressSelected(false);
  
  // Only one sync call after all updates
  syncToAgent();
}, [setSearchQuery, syncToAgent]);

// ‚ùå AVOID multiple useEffects with interconnected state dependencies
```

#### 4. Safe useEffect Dependency Guidelines
```typescript
// ‚úÖ SAFE DEPENDENCIES - Include these in useEffect deps:
// - Props values
// - State values from useState
// - Computed values that change
// - Values from context
// - Values from custom hooks return

// ‚ùå NEVER INCLUDE - These cause infinite loops:
// - setState functions (from useState or Zustand)
// - Stable callback functions 
// - Functions from useCallback with empty deps []
// - queryClient, dispatch, or other stable utilities
// - Refs (useRef values)
```

#### 5. React Query + Zustand Integration Pattern
```typescript
// ‚úÖ CORRECT - Direct data flow without sync loops
const { data: suggestions, isLoading } = useQuery({
  queryKey: ['addressSearch', searchQuery],
  queryFn: () => getPlaceSuggestionsAction({ query: searchQuery })
});

// ‚úÖ Agent gets data directly from React Query (no intermediate sync)
const { syncToAgent } = useAgentSync(); // Gets data via queryClient.getQueryData()

// ‚ùå NEVER DO THIS - Creates sync loops
// useEffect(() => {
//   setApiResults({ suggestions, isLoading }); // ‚ùå Unnecessary intermediate sync
// }, [suggestions, isLoading, setApiResults]);
```

### üîç DEBUGGING INFINITE LOOPS

#### Warning Signs to Watch For:
1. **React DevTools showing rapid re-renders**
2. **Console errors about "Maximum update depth exceeded"**
3. **Browser becoming unresponsive**
4. **Multiple HMR updates in rapid succession**

#### Quick Fix Checklist:
1. ‚úÖ Remove all state setters from useEffect dependencies
2. ‚úÖ Remove all Zustand actions from useEffect dependencies  
3. ‚úÖ Make callback functions stable with empty deps []
4. ‚úÖ Eliminate useEffects that update state based on state dependencies
5. ‚úÖ Move complex state logic to event handlers instead of effects
6. ‚úÖ Use getState() pattern instead of reactive dependencies for utilities

#### Emergency Fix - Remove Problematic Code:
```typescript
// When in doubt, DELETE problematic useEffects entirely
// It's better to handle state updates imperatively in event handlers
// than to create complex reactive dependency chains

// ‚ùå DELETE THIS if it's causing loops:
// useEffect(() => {
//   // Complex state update logic
// }, [/* many dependencies */]);

// ‚úÖ REPLACE WITH imperative updates in handlers:
const handleEvent = useCallback(() => {
  // Update state directly in response to user action
  updateState();
  syncToAgent();
}, []);
```

## FORBIDDEN PATTERNS ‚ùå

### 1. Separate Storage for AI vs Manual Results
```typescript
// ‚ùå NEVER DO THIS
const [aiSuggestions, setAiSuggestions] = useState<Suggestion[]>([]);
const { data: suggestions } = useQuery(['places', query]);
const currentSuggestions = isRecording ? aiSuggestions : suggestions;

// ‚ùå NEVER DO THIS  
const handleAIResult = (results) => {
  setAiSuggestions(results); // Bypasses React Query
}
```

### 2. Client Tools Bypassing Shared State Manipulation
```typescript
// ‚ùå NEVER DO THIS - Agent bypasses shared state
searchAddress: async (params) => {
  const result = await api.search(query);
  setLocalState(result.suggestions); // Bypasses shared state manipulation
}
```

### 3. Simple Sync Without Validation
```typescript
// ‚ùå NEVER DO THIS - Simple sync fails in complex scenarios
setSelectedResult(newResult);
syncToAgent(); // No validation or timing coordination
```

### 4. Mode Interference
```typescript
// ‚ùå NEVER DO THIS - Allows autocomplete during voice
const { data: suggestions } = useQuery({
  queryKey: ['autocomplete', query],
  enabled: !!query // Missing !isRecording
});
```

### 5. Removing Persistent Cache
```typescript
// ‚ùå NEVER DO THIS - Breaks conversation state survival
// const agentSuggestionsCache = useRef<Suggestion[]>([]); // DELETED
// This breaks agent context across conversation resets
```

## REQUIRED PATTERNS ‚úÖ

### 1. Multi-Modal Query Management
```typescript
// ‚úÖ ALWAYS DO THIS - Mode isolation with different query keys
const { 
  data: autocompleteSuggestions = [], 
  isLoading: isAutocompleteLoading 
} = useQuery({
  queryKey: ['autocomplete', debouncedSearchQuery],
  queryFn: async () => getPlaceSuggestionsAction({ 
    query: debouncedSearchQuery,
    isAutocomplete: true,
    sessionToken: getSessionToken()
  }),
  enabled: !!debouncedSearchQuery && !isRecording, // Mode isolation
  staleTime: 5 * 60 * 1000
});

const { 
  data: aiSuggestions = [] 
} = useQuery({
  queryKey: ['aiSuggestions', searchQuery],
  queryFn: async () => [], // Managed by clientTools
  enabled: false, // Updated via queryClient.setQueryData
  staleTime: Infinity
});
```

### 2. Persistent Agent Cache (Conversation Survival)
```typescript
// ‚úÖ REQUIRED - Survives ElevenLabs conversation resets
const agentSuggestionsCache = useRef<Suggestion[]>([]);
const agentCacheQuery = useRef<string>('');
const sessionTokenRef = useRef<string | null>(null);

// ‚úÖ Agent manipulates shared state (same as user actions)
const searchAddress = async (params: unknown) => {
  const result = await getPlaceSuggestionsAction({ query });
  
  if (result.success && result.suggestions) {
    // Manipulate persistent cache (shared state)
    agentSuggestionsCache.current = result.suggestions;
    agentCacheQuery.current = query;
    
    // Manipulate React Query (shared state)
    queryClient.setQueryData(['aiSuggestions', query], result.suggestions);
    
    // Sync manipulated state to agent
    await performReliableSync('ai-search');
  }
};
```

### 3. Reliable Multi-Step Sync Pattern
```typescript
// ‚úÖ REQUIRED - Handles asynchronous timing challenges
const performReliableSync = useCallback(async (context: string = 'general') => {
  try {
    // 1. Ensure React state updates are processed
    await new Promise(resolve => setTimeout(resolve, 0));
    
    // 2. Perform initial sync
    syncToAgent();
    
    // 3. Wait for state propagation
    await new Promise(resolve => setTimeout(resolve, 50));
    
    // 4. Validate synchronization
    const storeState = useAddressFinderStore.getState();
    const hasValidState = storeState.selectedResult?.description || storeState.searchQuery;
    
    if (hasValidState) {
      // 5. Confirmation sync
      syncToAgent();
    }
  } catch (error) {
    console.error(`Sync failed for ${context}:`, error);
  }
}, [syncToAgent]);

// ‚úÖ Use after all critical state changes
setSelectedResult(result);
performReliableSync('user-selection').catch(console.error);
```

### 4. Conflict Resolution Pattern
```typescript
// ‚úÖ REQUIRED - User actions manipulate shared state (take precedence over agent)
const handleSelectResult = useCallback((result: Suggestion) => {
  // Manipulate shared state (user action)
  setSelectedResult(result);        // ‚Üê Manipulate Zustand state
  setSearchQuery(result.description); // ‚Üê Manipulate search state
  
  // Notify agent during conversation (prevent override)
  if (isRecording && conversation.status === 'connected') {
    const selectionMessage = `I have selected "${result.description}" from the available options. Please acknowledge this selection and do not use the selectSuggestion tool - the selection is already confirmed.`;
    conversation.sendUserMessage?.(selectionMessage);
  }
  
  // Sync manipulated state to agent
  performReliableSync('user-selection').catch(console.error);
}, [setSelectedResult, setSearchQuery, isRecording, conversation, performReliableSync]);
```

### 5. Source Priority Deduplication
```typescript
// ‚úÖ REQUIRED - Handle multiple suggestion sources with priority
const deduplicateSuggestions = <T extends Suggestion & { source: string }>(
  suggestions: T[]
): T[] => {
  const sourcePriority = { 
    agentCache: 4, 
    unified: 3, 
    ai: 2, 
    autocomplete: 1 
  };
  
  return suggestions.reduce((acc, current) => {
    const existingIndex = acc.findIndex(item => item.placeId === current.placeId);
    
    if (existingIndex === -1) {
      acc.push(current);
    } else {
      const currentPriority = sourcePriority[current.source as keyof typeof sourcePriority] || 0;
      const existingPriority = sourcePriority[acc[existingIndex].source as keyof typeof sourcePriority] || 0;
      
      if (currentPriority > existingPriority) {
        acc[existingIndex] = current;
      }
    }
    
    return acc;
  }, [] as T[]);
};
```

## STATE MANIPULATION SYNCHRONIZATION FLOW

### How Synchronization Works Through State Manipulation:

```
User Types ‚Üí Manipulate searchQuery state ‚Üí Sync to Agent ‚Üí Agent knows user typed
User Clicks ‚Üí Manipulate selectedResult state ‚Üí Sync to Agent ‚Üí Agent knows user selected  
Agent Searches ‚Üí Manipulate React Query cache ‚Üí Sync to Agent ‚Üí UI shows agent results
Agent Selects ‚Üí Manipulate selectedResult state ‚Üí Sync to Agent ‚Üí UI shows agent choice
```

### Key Rules for State Manipulation:
1. **Both UI and Agent manipulate the SAME shared state stores**
2. **Every state manipulation MUST be followed by syncToAgent()**  
3. **User actions manipulate Zustand state first**
4. **Agent actions manipulate React Query state first**
5. **All manipulations flow through the same synchronization hooks**

## MULTI-MODAL STATE FLOW

## REQUIRED DATA FLOW
```
API Call ‚Üí React Query ‚Üí Zustand ‚Üí ElevenLabs Variables ‚Üí Agent
```

## MANDATORY SYNC HOOK USAGE
```typescript
// ‚úÖ Use centralized sync hook
const { syncToAgent } = useAgentSync();

// ‚úÖ Call after every state change that affects agent
useEffect(() => {
  syncToAgent();
}, [/* relevant dependencies */]);
```

## ZUSTAND STORE REQUIREMENTS
- Store UI-specific state only (isRecording, selectedResult, currentIntent)
- API results stored in React Query, referenced in Zustand for agent sync
- Always include syncToAgent() in action functions
- Never store raw API responses - store normalized UI state
- Include user interaction tracking (inputHistory, clickHistory)
- Track user action context for agent awareness

## CLIENT TOOLS REQUIREMENTS
- Must use queryClient.setQueryData() or invalidateQueries() for updates
- Must call syncToAgent() after React Query updates
- Must include loading/error states in responses
- Must wait for React Query state updates before returning

## AGENT SYNC REQUIREMENTS
- Sync comprehensive state including API loading/error states
- Include React Query cache status in agent variables
- Provide unified suggestions regardless of source (manual/AI)
- Update ElevenLabs variables on every state change
- Include user interaction context (last action, input method, capabilities)
- Track user action history for conversation context
- Notify agent of all user interactions (typing, clicking, form submission)

## VALIDATION RULES
1. No useState for API results - use React Query only
2. All agent client tools must update React Query first
3. Every primary state change must trigger a cascading sync via the centralized `useEffect` hook. Direct calls to `syncToAgent()` from event handlers are forbidden.
4. Agent must see same data as UI (no dual sources)
5. Include isLoading and error states in all agent communications
6. All user interactions must be tracked and synced to agent
7. Include user action context in agent state
8. Event handlers must track user actions before state updates

## EXAMPLES

### ‚úÖ Correct Implementation
```typescript
// Component with proper state management
export function AddressFinder() {
  const { syncToAgent } = useAgentSync();
  const queryClient = useQueryClient();
  
  // Single source for all suggestions
  const { data: suggestions, isLoading, error } = useQuery({
    queryKey: ['addressSearch', searchQuery],
    queryFn: () => getPlaceSuggestionsAction({ query: searchQuery })
  });
  
  // Client tools update React Query
  const clientTools = {
    searchAddress: async (params) => {
      const result = await api.search(query);
      
      // Update React Query cache
      queryClient.setQueryData(['addressSearch', query, 'ai'], {
        suggestions: result.suggestions,
        source: 'ai',
        timestamp: Date.now()
      });
      
      syncToAgent(); // Always sync
      return JSON.stringify({ status: 'success', count: result.suggestions.length });
    }
  };
  
  // User action handlers with tracking
  const handleUserInput = useCallback((value) => {
    setSearchQuery(value);
    
    // Track user action for agent
    const windowWithElevenLabs = window as any;
    windowWithElevenLabs.setVariable?.("lastUserAction", {
      type: "typing",
      value,
      timestamp: Date.now()
    });
    
    syncToAgent();
  }, [setSearchQuery, syncToAgent]);
  
  const handleSuggestionClick = useCallback((suggestion) => {
    setSelectedResult(suggestion);
    
    // Track user action for agent
    const windowWithElevenLabs = window as any;
    windowWithElevenLabs.setVariable?.("lastUserAction", {
      type: "click",
      action: "select_suggestion",
      data: suggestion,
      timestamp: Date.now()
    });
    
    syncToAgent();
  }, [setSelectedResult, syncToAgent]);
  
  // Sync to agent on state changes
  useEffect(() => {
    syncToAgent();
  }, [suggestions, isLoading, error, selectedResult]);
}
```

### ‚ùå Incorrect Implementation
```typescript
// DON'T DO THIS - dual storage anti-pattern
export function AddressFinder() {
  const [aiSuggestions, setAiSuggestions] = useState([]);
  const { data: suggestions } = useQuery(['places', query]);
  
  const clientTools = {
    searchAddress: async (params) => {
      const result = await api.search(query);
      setAiSuggestions(result.suggestions); // Bypasses React Query
      // Missing syncToAgent()
    }
  };
  
  // Dual storage confusion
  const currentSuggestions = isRecording ? aiSuggestions : suggestions;
  
  // Missing user action tracking
  const handleClick = (suggestion) => {
    setSelectedResult(suggestion); // No agent notification
  };
  
  const handleInput = (value) => {
    setSearchQuery(value); // No user action tracking
  };
}
```

## USER INTERACTION REQUIREMENTS

### All Event Handlers Must:
```typescript
// ‚úÖ CORRECT: Event handlers perform ONLY primary state changes
const handleUserAction = useCallback((data) => {
  // 1. Perform Primary Change: Update application state directly.
  updateState(data);
  
  // 2. Perform Primary Change: Track the user action for the agent.
  const windowWithElevenLabs = window as any;
  windowWithElevenLabs.setVariable?.("lastUserAction", {
    type: "click" | "typing" | "submit" | "focus",
    action: "specific_action",
    data,
    timestamp: Date.now(),
    context: "component_context"
  });
  
  // NO syncToAgent() call here. The state change itself will trigger the
  // centralized useEffect hook, which handles the synchronization as a
  // secondary, cascading reaction.
}, [updateState]);
```

### Required User Action Types:
- **typing**: Text input changes
- **click**: Button/suggestion clicks  
- **submit**: Form submissions
- **focus**: Element focus/blur
- **mode_change**: UI mode toggles
- **clear**: Clear/reset actions

## WIDGET ARCHITECTURE ENFORCEMENT

### CRITICAL: Self-Contained Widget Requirements
Every widget component must be completely self-sufficient with minimal external dependencies.

#### ‚úÖ REQUIRED Widget Patterns:
```typescript
// ‚úÖ CORRECT: Minimal interface with single callback
interface WidgetProps {
  onSelect: (data: SelectionType) => void;          // ‚úÖ Primary action callback
  onError?: (error: Error) => void;                // ‚úÖ Optional error callback  
  onComplete?: () => void;                         // ‚úÖ Optional completion callback
  disabled?: boolean;                              // ‚úÖ Simple state control
  className?: string;                              // ‚úÖ Styling only
}

// ‚úÖ CORRECT: Widget handles own queries and state
export const SelfContainedWidget = ({ onSelect }: WidgetProps) => {
  const [internalState, setInternalState] = useState();
  
  // ‚úÖ Widget's own independent query
  const { data, isLoading } = useQuery({
    queryKey: ['widgetData', internalState],
    queryFn: () => api.getData(internalState),
    enabled: !!internalState
  });
  
  // ‚úÖ Widget handles all internal complexity
  const handleInternalAction = (item) => {
    setInternalState(item);
    onSelect(item); // Simple callback to Brain
  };
  
  return (/* Widget UI with internal state management */);
};
```

#### ‚ùå FORBIDDEN Widget Anti-Patterns:
```typescript
// ‚ùå NEVER DO THIS: Complex interface with multiple data dependencies
interface ComplexWidgetProps {
  onSearch: (query: string) => void;               // ‚ùå Parent manages queries
  isLoading: boolean;                              // ‚ùå Parent manages loading state
  suggestions?: DataType[];                        // ‚ùå Parent provides data
  onSelect: (item: DataType) => void;              // ‚ùå Mixed responsibilities
  searchQuery: string;                             // ‚ùå Parent controls input
  onClear: () => void;                             // ‚ùå Parent manages clearing
  sessionToken?: string;                           // ‚ùå Parent manages sessions
  error?: string;                                  // ‚ùå Parent handles errors
}

// ‚ùå NEVER DO THIS: Widget depends on parent for data/queries
export const DependentWidget = ({ 
  onSearch, isLoading, suggestions, searchQuery, onClear 
}: ComplexWidgetProps) => {
  // ‚ùå No internal state management
  // ‚ùå Relies on parent for everything
  // ‚ùå Cannot be tested in isolation
  // ‚ùå Causes prop drilling and complex interfaces
};
```

### MANDATORY Widget Isolation Rules

#### 1. ‚úÖ Widgets MUST Be Self-Contained
- **Own API calls**: Use independent `useQuery` with unique keys
- **Own state management**: All internal state via `useState`/`useReducer`
- **Own error handling**: Internal error states and recovery
- **Own session management**: Session tokens, cleanup, optimization
- **Own UX logic**: Debouncing, validation, formatting, animations

#### 2. ‚ùå Widgets MUST NEVER Import Global State
```typescript
// ‚ùå FORBIDDEN: Importing global stores
import { useAddressFinderStore } from '~/stores/addressFinderStore';
import { useAgentSync } from '~/hooks/useAgentSync';

// ‚ùå FORBIDDEN: Accessing global state
const { isRecording, syncToAgent } = useAddressFinderStore();

// ‚ùå FORBIDDEN: Global agent communication
syncToAgent();
```

#### 3. ‚úÖ Widgets MUST Use Minimal Callback Interfaces
- **Maximum 3 callbacks**: `onSelect`, `onError`, `onComplete`
- **Simple data types**: Pass only essential data, not complex state
- **No state setters**: Never pass `setState` functions as props
- **No query controls**: Widget manages own queries internally

#### 4. ‚ùå FORBIDDEN: Complex Prop Interfaces
If a widget needs more than 5 props, it violates self-containment:
```typescript
// ‚ùå FORBIDDEN: Too many props indicates poor separation
interface OverlyComplexProps {
  prop1: string;    // 1
  prop2: boolean;   // 2  
  prop3: () => void; // 3
  prop4: any[];     // 4
  prop5: object;    // 5
  prop6: string;    // 6 ‚Üê TOO MANY - redesign needed
}
```

## BRAIN COMPONENT ENFORCEMENT

### ‚úÖ REQUIRED Brain Patterns:
```typescript
// ‚úÖ Brain orchestrates with minimal widget interfaces
export default function BrainComponent() {
  const { syncToAgent } = useAgentSync();
  
  // ‚úÖ Simple widget usage
  const handleSelection = useCallback((data: SelectionType) => {
    updateGlobalState(data);
    syncToAgent();
  }, [updateGlobalState, syncToAgent]);
  
  return (
    <div>
      <SelfContainedWidget onSelect={handleSelection} />
    </div>
  );
}
```

### ‚ùå FORBIDDEN Brain Anti-Patterns:
```typescript
// ‚ùå NEVER DO THIS: Complex widget management
<ComplexWidget
  data={complexData}
  isLoading={isLoading}
  onSearch={handleSearch}
  onSelect={handleSelect}
  onClear={handleClear}
  searchQuery={searchQuery}
  sessionToken={sessionToken}
  error={error}
/>
```

## HYBRID MODE ENFORCEMENT

### ‚úÖ REQUIRED Hybrid Mode Patterns:
```typescript
// ‚úÖ CORRECT: Keep conversation active during requestManualInput
requestManualInput: async (params) => {
  // ‚úÖ NO conversation termination
  setAgentRequestedManual(true);
  addHistory({ type: 'agent', text: `ü§ñ ‚Üí üìù ${params.reason}` });
  
  return JSON.stringify({
    status: "hybrid_mode_activated",
    message: "Manual input enabled - conversation continues"
  });
}

// ‚úÖ CORRECT: Conditional rendering for hybrid mode
const shouldShowManualForm = !isRecording || agentRequestedManual;
```

### ‚ùå FORBIDDEN Hybrid Mode Anti-Patterns:
```typescript
// ‚ùå NEVER DO THIS: Stop conversation during manual input
requestManualInput: async (params) => {
  await conversation.endSession();  // ‚ùå Breaks hybrid mode
  setIsRecording(false);           // ‚ùå Ends conversation
  stopRecording();                 // ‚ùå Not collaborative
}
```

## AUTOMATIC VIOLATION DETECTION

### Widget Violation Patterns to Flag:
- **Import violations**: `import.*store.*|import.*useAgentSync`
- **Complex interfaces**: More than 5 props in widget interface
- **Prop drilling**: Props like `isLoading`, `suggestions`, `onSearch` together
- **State dependencies**: Props ending in `Query`, `State`, `Token`
- **Global calls**: `syncToAgent()`, `useAddressFinderStore()` in widgets

### Brain Violation Patterns to Flag:
- **Complex widget usage**: More than 3 props passed to widgets
- **Data prop passing**: Passing `data`, `suggestions`, `results` to widgets
- **State prop passing**: Passing `isLoading`, `error`, `query` to widgets
- **Session prop passing**: Passing `sessionToken`, `cache` to widgets

### Hybrid Mode Violation Patterns to Flag:
- **Conversation termination**: `endSession()`, `stopRecording()` in `requestManualInput`
- **Mode switching**: `setIsRecording(false)` in manual input tools
- **Missing continuity**: Not preserving conversation state during manual input

## UI BEHAVIOR RULES FOR AI SUGGESTIONS

### CRITICAL: AI Suggestions Display Logic
AI suggestions should ONLY be displayed when ALL of the following conditions are met:

#### ‚úÖ AI Suggestions Should Show When:
1. **Active conversation mode**: `isRecording === true`
2. **Suggestions available**: `suggestions.length > 0`
3. **No confirmed selection**: `!selectedResult` (user hasn't made a final choice)
4. **Agent-driven**: Suggestions came from agent `searchAddress` tool calls

#### ‚ùå AI Suggestions Should NEVER Show When:
1. **Manual mode**: `isRecording === false` (ManualSearchForm handles its own autocomplete)
2. **User has selected**: `selectedResult` exists (user made a confirmed selection)
3. **Pure autocomplete**: User is typing in manual mode (widget handles this internally)

#### üîß Implementation Pattern:
```typescript
// ‚úÖ CORRECT AI Suggestions Conditional Rendering
{suggestions.length > 0 && isRecording && !selectedResult && (
  <Card className="border-blue-200 bg-blue-50">
    <CardHeader>
      <CardTitle>ü§ñ AI-Generated Place Suggestions</CardTitle>
    </CardHeader>
    <CardContent>
      <SuggestionsDisplay suggestions={suggestions} onSelect={handleSelectResult} />
    </CardContent>
  </Card>
)}

// ‚ùå WRONG - Shows AI suggestions even when user made manual selection
{suggestions.length > 0 && (
  <Card>ü§ñ AI Suggestions</Card>
)}
```

### BRAIN VS WIDGET UI SEPARATION

#### ManualSearchForm Widget Autocomplete:
- **Independent query system**: Uses `['manualAutocomplete', query]` React Query key
- **Self-contained UI**: Dropdown shown/hidden by widget internally
- **Only during manual mode**: `!isRecording` or `agentRequestedManual` hybrid mode
- **Never interferes with AI suggestions**: Completely separate data flow

#### AI Suggestions Display:
- **Brain-controlled**: Managed by main route component
- **Agent-driven data**: Uses `['addressSearch', query]` React Query key
- **Only during conversation**: `isRecording === true`
- **Cleared on selection**: Hidden when `selectedResult` exists

### HYBRID MODE EXCEPTION
During hybrid mode (`agentRequestedManual === true`):
- **ManualSearchForm**: Enabled for user typing
- **AI Suggestions**: May still show if agent is actively searching
- **Clear separation**: Both can coexist but serve different purposes
- **Priority rule**: Manual selection always takes precedence and hides AI suggestions
